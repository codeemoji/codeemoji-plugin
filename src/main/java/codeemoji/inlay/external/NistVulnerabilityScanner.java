package codeemoji.inlay.external;

import org.json.JSONArray;
import org.json.JSONObject;

import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

public class NistVulnerabilityScanner extends VulnerabilityScanner<DependencyInfo, JSONObject> {

    private static final int NIST_BATCH_SIZE = 50;

    public NistVulnerabilityScanner(String baseUrl, String apiKey) {
        super(baseUrl, apiKey);
    }

    @Override
    public Map<DependencyInfo, List<VulnerabilityInfo>> scanVulnerability(DependencyInfo[] dependencies) {
        for (int i = 0; i < dependencies.length; i += NIST_BATCH_SIZE) {
            DependencyInfo[] batch = Arrays.copyOfRange(dependencies, i, Math.min(i + NIST_BATCH_SIZE, dependencies.length));
            scanSingleVulnerability(batch);
            if (i + NIST_BATCH_SIZE < dependencies.length) {
                try {
                    Thread.sleep(30000); // Wait for 30 seconds before the next batch - NIST directives with API_KEY
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        return vulnerabilityMap;
    }

    protected Map<DependencyInfo, List<VulnerabilityInfo>> scanSingleVulnerability(DependencyInfo[] dependencies) {
        List<CompletableFuture<JSONObject>> futures = Arrays.stream(dependencies)
                .map(this::scanVulnerabilityAsync)
                .collect(Collectors.toList());

        CompletableFuture<Void> allFutures = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));

        allFutures.thenAccept(v -> {
            JSONObject results = new JSONObject();
            JSONArray resultsArray = new JSONArray();
            for (CompletableFuture<JSONObject> future : futures) {
                try {
                    resultsArray.put(future.join());
                } catch (Exception e) {
                    System.err.println("Error processing a future: " + e.getMessage());
                }
            }
            results.put("results", resultsArray);
            processResponse(results, dependencies);
        }).exceptionally(this::handleError);

        // Wait for all futures to complete
        allFutures.join();

        return vulnerabilityMap;
    }

    @Override
    protected void processResponse(JSONObject results, DependencyInfo[] dependencies) {
        JSONArray resultsArray = results.getJSONArray("results");
        for (int i = 0; i < resultsArray.length(); i++) {
            JSONObject vulnerabilityReport = resultsArray.getJSONObject(i);
            DependencyInfo dep = dependencies[i];
            try {
                JSONArray vulnerabilitiesArray = vulnerabilityReport.getJSONArray("vulnerabilities");
                List<VulnerabilityInfo> vulnerabilities = parseVulnerabilityInfo(vulnerabilitiesArray);
                if (!vulnerabilities.isEmpty()) {
                    vulnerabilityMap.put(dep, vulnerabilities);
                }
            } catch (Exception e) {
                System.err.println("Error processing vulnerability report for " + dep.getName() + ": " + e.getMessage());
            }
        }
    }

    @Override
    protected Void handleError(Throwable throwable) {
        System.err.println("Error occurred while scanning dependencies: " + throwable.getMessage());
        throwable.printStackTrace();
        return null;
    }

    @Override
    protected CompletableFuture<JSONObject> scanVulnerabilityAsync(DependencyInfo dependency) {
        HttpRequest request = createRequest(dependency);
        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(response -> {
                    if (response.statusCode() == 200) {
                        return new JSONObject(response.body());
                    } else {
                        throw new RuntimeException("API request failed with status code: " + response.statusCode());
                    }
                });
    }

    @Override
    protected HttpRequest createRequest(DependencyInfo dependency) {
        String apiUrl = createUrl(dependency);

        return HttpRequest.newBuilder()
                .uri(URI.create(apiUrl))
                .header("apiKey", API_KEY )
                .GET()
                .build();
    }

    private String createUrl(DependencyInfo dependency) {
        String cpe = String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*", dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());
        String encodedCpe = URLEncoder.encode(cpe, StandardCharsets.UTF_8);
        return BASE_URL + "?cpeName=" + encodedCpe;
    }

    @Override
    protected List<VulnerabilityInfo> parseVulnerabilityInfo(JSONArray vulnerabilitiesArray) {
        List<VulnerabilityInfo> vulnerabilities = new ArrayList<>();


        for (int i = 0; i < vulnerabilitiesArray.length(); i++) {
            JSONObject vuln = vulnerabilitiesArray.getJSONObject(i);
            JSONObject cveInfo = vuln.getJSONObject("cve");

            String cve = cveInfo.getString("id");

            String description = "";
            JSONArray descriptions = cveInfo.getJSONArray("descriptions");
            for (int j = 0; j < descriptions.length(); j++) {
                JSONObject desc = descriptions.getJSONObject(j);
                if (desc.getString("lang").equals("en")) {
                    description = desc.getString("value");
                    break;
                }
            }

            String severity = "UNKNOWN";
            if (cveInfo.has("metrics")) {
                JSONObject metrics = cveInfo.getJSONObject("metrics");
                if (metrics.has("cvssMetricV31")) {
                    JSONArray cvssV31 = metrics.getJSONArray("cvssMetricV31");
                    if (cvssV31.length() > 0) {
                        JSONObject cvssData = cvssV31.getJSONObject(0).getJSONObject("cvssData");
                        severity = cvssData.getString("baseSeverity");
                    }
                }
            }

            vulnerabilities.add(new VulnerabilityInfo(cve, description, severity, VulnerabilityInfo.ScannerType.NIST));
        }

        return vulnerabilities;
    }


}
