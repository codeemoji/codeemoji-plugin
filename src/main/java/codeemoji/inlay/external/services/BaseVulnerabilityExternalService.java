package codeemoji.inlay.external.services;

import codeemoji.core.external.CEExternalService;
import codeemoji.core.util.CEUtils;
import codeemoji.inlay.external.DependencyInfo;
import codeemoji.inlay.external.VulnerabilityInfo;
import codeemoji.inlay.external.scanners.VulnerabilityScanner;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.libraries.Library;
import com.intellij.openapi.roots.libraries.LibraryTable;
import com.intellij.openapi.roots.libraries.LibraryTablesRegistrar;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiMethod;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

public abstract class BaseVulnerabilityExternalService implements CEExternalService<VirtualFile, Object> {
    protected final Map<VirtualFile, Object> persistedData = new HashMap<>();
    protected Map<DependencyInfo, List<VulnerabilityInfo>> vulnerabilityMap = new HashMap<>();
    protected DependencyInfo[] validDependecies;
    protected Library[] allLibraries;

    protected abstract VulnerabilityScanner getVulnerabilityScanner();

    @Override
    public void preProcess(@NotNull Project project) {
        persistedData.put(project.getWorkspaceFile(), null);
        validDependecies = getProjectLibraries(project);
        vulnerabilityMap = getVulnerabilityScanner().scanVulnerability(validDependecies);
    }

    public DependencyInfo[] getProjectLibraries(Project project) {
        LibraryTable librarytable = LibraryTablesRegistrar.getInstance().getLibraryTable(project);
        allLibraries = librarytable.getLibraries();
        return Arrays.stream(allLibraries)
                .map(dep -> {
                    try {
                        return CEUtils.getDependecyInfo(dep);
                    } catch (IllegalArgumentException e) {
                        System.err.println("Error processing dependency: " + dep.getName() + ". Error: " + e.getMessage());
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .toArray(DependencyInfo[]::new);
    }

    @Override
    public Map<VirtualFile, Object> getPersistedData() {
        return persistedData;
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    @Override
    public void buildInfo(@NotNull Map infoResult, @Nullable PsiElement element) {
        // useful to reduce the amount of externalInfo created.
        // externalInfos needed only for PsiMethods at the moment (Vulnerable Dependecies)
        if (!(element instanceof PsiMethod)) {
            return;
        }
        if (element != null && element.getProject() != null) {
            LibraryTable librarytable = LibraryTablesRegistrar.getInstance().getLibraryTable(element.getProject());
            Library[] elementProjectLibraries = librarytable.getLibraries();
            //if (!elementProjectLibraries.equals(allLibraries)) {
            // approximation to avoid a too long wait on comparison
            if(elementProjectLibraries.length != allLibraries.length) {
                validDependecies = getProjectLibraries(element.getProject());
                vulnerabilityMap = getVulnerabilityScanner().scanVulnerability(validDependecies);
            }
            // needed sometimes because of loading while scanning indexes
            else if (validDependecies.length == 0) {
                validDependecies = getProjectLibraries(element.getProject());
                if (validDependecies.length != 0) {
                    vulnerabilityMap = getVulnerabilityScanner().scanVulnerability(validDependecies);
                }

            }
        }
        for (Map.Entry<DependencyInfo, List<VulnerabilityInfo>> entry : vulnerabilityMap.entrySet()) {
            infoResult.put(entry.getKey(), entry.getValue());
        }
    }

    @Nullable
    public Object retrieveData(VirtualFile file) {
        return persistedData.get(file);
    }
}